%%%
%%%
%%% NEED BODY PITCH/ROLL PLOTS DURING ZMP SHIT
%%%
%%%
%%% 

\chapter{Gaiting and Gait-Stability Control}
	\label{ch::gait_control}
	

	\section{Overview}

		Legged robotic systems have long employed motion controllers based on limit cycle oscillators and, more recently, Central Pattern Generators (CPGs)  for the purpose of generating bio-mimetic gaits \cite{Matsuoka1985,Collins1993,Endo2004,Righetti2006,Ijspeert2008,Matos2010,Ajallooeian2013,Park2014,Fukuoka2015}. Since these motion control methods are open-loop motion planners (\IE not inherently formulated to incorporate feedback) they do not perform any active system stabilization on their own accord. As a result, implementations involving these  locomotion methods often require auxiliary control mechanisms which provide gait stability. Fixed point methods, which include considerations of the system's zero-moment point (ZMP) and center of gravity (COG), are utilized in the design of stable oscillator driven gaits. These methods are summarized in \cite{Wieber2015}. %add ZMP references%

		Developments in CPG-based gait controllers have led to the incorporation of ``reflexive" feedback mechanisms aimed at correcting foot-placement during gaiting on uneven terrain or various types of surfaces. One such approach involves adding active compliance to each leg by directly modifying CPG oscillator units through feedback-driven modulations. In \cite{Fukuoka2003,Endo2004}, a CPG for each leg is modified by a neural oscillator with one tuning parameter. 

		This chapter will detail a similar reflex-adaptive CPG gait generation method which utilizes IMU feedback to modify CPG limit-cycle parameters. Additionally, this section will present related motion-control methods implemented on the BlueFoot platform which aid in gait stabilization, including a virtual force-based foot placement planner and a ZMP-based body placement controller as well as a learning-based control technique used to level BlueFoot's trunk during gaiting.


	\section{Central Pattern Generator (CPG) Based Gaiting}
		\label{sec::cpg_gait_control}
		A CPG, which includes a reflexive mechanism using sensory feedback, is utilized as the core of BlueFoot's gait generation algorithm. As previously introduced, CPGs are a form of neural oscillator network which mimic biological mechanisms for repetitive motor tasks \cite{Ijspeert2008,Collins1993}. CPGs commonly consist of a network of multi-state unit-oscillators. These unit-oscillators are coupled such that the motion of one oscillator drives or attenuates the motion of other oscillators it is connected to, creating phase-locked limit cycles.

		In this context, the limit-cycles generated with a CPG will be utilized to drive a quadruped  walking gait by mapping oscillator outputs to foot position controls. CPGs are widely used in this way as they provide a compact method for prescribing rhythmic gaits with variable stepping sequences \cite{Righetti2006,Castro2008,Li2014}. CPG-driven gait controllers are convenient as they allow for continuous transitioning between gaiting patterns through the modification of oscillator coupling. Reflexes are built into the oscillators which use IMU measurements to modulate the CPGs unit oscillators, as will be outlined later in this section.

		The CPG implemented on BlueFoot consists of four modified two-state Hopf Oscillators connected through a coupling matrix $K$. The states of each \Ith unit Hopf Oscillator are designated by the pair $\{y_{1,i},y_{2,i}\}$. These oscillator states are stacked into the vectors $y_{1}\in \RRe^{4}$ and $y_{2}\in \RRe^{4}$, which are composed as follows:
			\begin{eqnarray*}
				y_{1} &=& \sbrack{y_{1,1},y_{1,2},y_{1,3},y_{1,4}}^{T}\nonumber\\
				y_{2} &=& \sbrack{y_{2,1},y_{2,2},y_{2,3},y_{2,4}}^{T}
			\end{eqnarray*}
		The oscillator output vector $y_{2}$, parameterizes the trajectories of each \Ith foot. The resulting reflexive CPG system, written which respect to the stacked-state vectors $y_{1}$ and $y_{2}$, is described by
			\begin{eqnarray}
				\dot{y}_{1} &=& A_{1}\wrap{ \Psi_{M} M\wrap{y_{1},y_{2}} - \Gamma}{y}_{1} + \Psi_{\omega} W {y}_{2} 			\nonumber\\
				\dot{y}_{2} &=& A_{2}\wrap{ \Psi_{M} M\wrap{y_{1},y_{2}} - \Gamma}{y}_{2} - \Psi_{\omega} W {y}_{1} + K {y}_{2}	%\nonumber
				\label{eq::cpg_ss_def}
			\end{eqnarray}
		where $M\wrap{y_{1},y_{2}} \in \RRe^{4\times4}$ is defined as
			\newcommand{\yy}[1]{y_{1,#1}^{2} + y_{2,#1}^{2}}
			\begin{equation*}
				M\wrap{y_{1},y_{2}} = \left[
				\begin{array}{cccc}
				\yy{1} 	& 	0 		& 	0 		& 	0 		\\ 
				0		& 	\yy{2}  & 	0 		& 	0 		\\ 
				0 		& 	0 		& 	\yy{3}  & 	0 		\\ 
				0 		& 	0 		& 	0 		& 	\yy{4}  \\ 
				\end{array}
				\right],
			\end{equation*}
		${A_{1},A_{2}, \Psi_{M}, \Psi_{\omega}} \InRe{4\times4}$ are constant oscillator gain matrices; and $\Gamma$ and $W$ are diagonal matrices, defined by
			\begin{equation*}
				\Gamma = \left[
				\begin{array}{cccc}
				\gamma_{1} 	& 	0 				& 	0 				& 	0 		\\ 
				0				& 	\gamma_{2} 	& 	0 				& 	0 		\\ 
				0 				& 	0 				& 	\gamma_{3} 	& 	0 		\\ 
				0 				& 	0 				& 	0 				& 	\gamma_{4}  \\ 
				\end{array}
				\right],
				\Sep
				W = \left[
				\begin{array}{cccc}
				\omega_{1} 	& 	0 				& 	0 				& 	0 		\\ 
				0				& 	\omega_{2} 	& 	0 				& 	0 		\\ 
				0 				& 	0 				& 	\omega_{3} 	& 	0 		\\ 
				0 				& 	0 				& 	0 				& 	\omega_{4}  \\ 
				\end{array}
				\right],
			\end{equation*}
		which define the peak-to-peak output amplitude, $\gamma_{i}$, and frequency, $\omega_{i}$, of each \Ith unit oscillator in the CPG network. To reiterate, the matrix $K$ defines an oscillator coupling matrix, which will be detailed in the upcoming sections. A more specific design of the matrix $W$, with respect to a gait frequency parameter, $\omega_{s}$, is provided in \ref{eq::cpg_W_matrix_def}.


		\subsection{Reflexive Gait Adaptations}

			Feedback signals are incorporated into the CPG through the frequency modulation matrix $\Psi_{\omega}$ and amplitude modulation matrix $\Psi_{M}$. These modulation parameters are generated using state estimates of the platform's orientation and angular rate. The platform orientation state-estimate, $\hat{\theta}_{b}$, is supplied to the controller from an Extended Kalman Filter utilizing inertial measurement and magnetometer feedback (which are separately calibrated). The platform's angular rate is output by an angular rate-gyro sensor.

			Feedback-based corrections to the CPG aid in tracking a specified body orientation $\theta_{b}^{r}$ during gaiting. To achieve higher system velocities, it is often necessary to perform a gait wherein multiple legs leave contact with the ground. Configurations such as these would cause a quadruped robot to tip in the direction of the non-planted legs, thus disturbing $\theta_{b}$. These disturbances are counteracted, in part, by adjusting the CPG such that the amount of torque applied on the main body by legs in flight is actively limited. This is done by adjusting stepping height and time-of-flight according to a measure of disturbance (essentially, the amount and rate of tipping). These adjustments have been formulated to mimic reflexive behaviors that might be performed by a biological system.

			When the robot's body begins to fall in particular direction (\IE is disturbed by legs in flight during gaiting), the disturbance signal 
				\begin{equation}
					\dot{\epsilon}_{\theta} = {R}_{z_{b}}\wrap{\frac{\pi}{2}}\wrap{\dot{\hat{\theta}}_{b} - \dot{\theta}_{b}^{r}}
				\end{equation}
			is non-zero. $\dot{\epsilon}_{\theta}$ represents a measure of translational drift recovered from gyroscopic sensor measurements. ${R}_{z_{b}}\wrap{\frac{\pi}{2}}$ represents a rotation by $\frac{\pi}{2}$ about the z-axis of the body frame $O_{b}$. $\dot{\epsilon}_{\theta}$ is mapped to the parameters $\Psi_{\omega}$ and $\Psi_{M}$ by
				\begin{eqnarray}
					\psi_{i} 			&=& \Sig{  w_{i} \upsilon_{i} - w_{i} c_{i} } (1-{\mu}_{i}) 	\nonumber\\
					\Psi_{\omega} 		&=& I + A_{\omega}\DiagMat{ \psi_{i} } 						\nonumber\\
					\Psi_{M}			&=& I - A_{\mu} \DiagMat{  \psi_{i} } 
					\label{eq::cpg_modulations}
				\end{eqnarray}
			where
				\begin{eqnarray}
					\upsilon_{i} 		&=& \norm{ \dot{\epsilon}_{\theta} } \wrap{1 + \Normalize{\Delta x_{i}}^T  \Normalize{ \dot{\epsilon}_{\theta}  } }	\nonumber\\\
					\Delta x_{i}		&=& {p}_{i,e} - {p}_{b}
				\end{eqnarray}
			with $\{w_{i}, c_{i}\} \InRe{}$ and $\{A_{\mu}, A_{\omega}\} \InRe{4\times4}$ being tunable gains. ${\mu}_{i}$ is used to represent the contact state of each \Ith foot, and takes on a value of ${\mu}_{i}=1$ when a foot is in contact and ${\mu}_{i}=0$ when it is not. $\Sig{*}$ represents the standard sigmoid step function which takes a scalar argument $(*)$. The signal $\upsilon_{i}$ represents a projection of $\dot{\epsilon}_{\theta}$ into the unit-vector emanating from ${p}_{b}$ to each \Ith foot. This projection delegates the level of adjustment to each \Ith oscillator as a result of $\dot{\epsilon}_{\theta}$. Finally, $\DiagMat{  \psi_{i} } \in \RRe^{4\times4}$ defines a diagonal matrix whose \Ith diagonal element is $\psi_{i}\SSep\forall i\in\{1,2,3,4\}$.	

			Adjusting $\Psi_{\omega}$ by the method delineated in \ref{eq::cpg_modulations} serves to shorten the stepping period of a leg in flight given greater values of $\dot{\epsilon}_{\theta}$. Likewise, $\Psi_{M}$ is adjusted to decrease the height of each foot in flight. The frequency of a full gaiting cycle is prescribed via $\omega_{s}$ and duty-factor $\alpha \in \sbrack{0,1}$ as in \cite{Matos2010}. The matrix $W$ is formed from  $\omega_{s}$ and $\alpha$ as follows:
				\newcommand{\Wel}[1]{\frac{1}{1+e^{#1}}}
				\begin{equation}
						W = 
						\omega_{s}\alpha 
						\left[	
							\begin{array}{ccc}
								\Wel{\zeta y_{2,1}} 		& 0 			& 0  \\
								0 							& \ddots 		& 0  \\
								0							& 0		 		& \Wel{\zeta y_{2,4}}
							\end{array}
						\right] + 
						\omega_{s}(1-\alpha) 
						\left[	
							\begin{array}{cccc}
								\Wel{-\zeta y_{2,1}} 		& 0 			& 0  \\
								0 							& \ddots 		& 0  \\
								0							& 0		 		& \Wel{-\zeta y_{2,4}}
							\end{array}
						\right]
					\label{eq::cpg_W_matrix_def}
				\end{equation}
			and $\zeta$ being a sensitivity tuning parameter. A linear mapping between commanded platform velocity, $v^{r}$; the magnitude of the commanded rotational rate, $\norm{\omega^{r}}$; and $\omega_{s}$ is prescribed such that stepping-cycle frequency is adjusted proportionally with respect to the desired velocity and turning rate of the system, as follows:
				\begin{equation}
					\omega_{s} = a_{v}v^{r} + a_{\omega}\abs{\omega^{r}}
				\end{equation}
			where $a_{v}$ and $a_{\omega}$ are scalar gains. In BlueFoot's CPG implementation, the coupling matrix $K$ takes on the values $k_{i,j} \in \sbrack{-1,1}$. Each element of the coupling matrix, $k_{i,j}$, is utilized to adjust the phase offsets between the unit-oscillators. Furthermore, setting $k_{i,j}=1$ causes the \Jth oscillator to attract the \Ith oscillator  towards a  positive peak, and vice-versa. Setting $k_{i,j}=0$ effectively disconnects \Ith and \Jth oscillators. 

			Figures~\ref{fig::cpg_phase2_45} and \ref{fig::cpg_phase4_45} depict the CPG output, $y_{2}$, and corresponding unit-oscillator phase portraits of the oscillator dynamics, given by \ref{eq::cpg_ss_def} with the feedback mechanism given in \ref{eq::cpg_modulations} used during simulations of BlueFoot's default two-pace trotting and four-pace walking gaits, respectively. The associated $K$ matrix prescribing this gaiting pattern is a modified version of $K$ for a 2-pace trot gait presented in \cite{Rutishauser2008}, since this generates a more effective and fluid gait when applied to BlueFoot's gait controller
				\begin{equation}
						K\equiv 
						\left[ 
						\begin{array}{cccc}
						 0	   	&	-1   	&	 	 1   	&		-0.5\\
						-1	   	&	 0   	&	 	-0.5   	&		 1 	\\
						-1    	&	-0.5   	&		0    	&	 	-1 	\\
						-0.5	&	 1   	&		-1    	&		 0
						\end{array}
						\right].
						\label{eq::K_two_pace}
				\end{equation}
			A comparable four-pace \emph{walking} gait can be achieved by slight sign modifications on the elements of  \ref{eq::K_two_pace}, which yields \ref{eq::K_four_pace} as follows:
				\begin{equation}
						K\equiv 
						\left[ 
						\begin{array}{cccc}
						 0	   	&	-1   	&	 	 1   	&	  	-0.5\\
						-1	   	&	 0   	&	 	-0.5   	&		 1 	\\
						-1    	&	 0.5   	&		 0    	&	 	-1 	\\
						 0.5	&	-1   	&		-1    	&		 0
						\end{array}
						\right].
						\label{eq::K_four_pace}
				\end{equation}
			%The output state, $y_{i}$ and phase portrait form from $x_{i},y_{i}$ of each \Ith oscillator are shown in Figures \ref{fig::cpg_phase2_45} and \ref{fig::cpg_phase3_45} for a two-paced and four-paced gait, respectively. The two-paced gait was produced using the coupling matrix defined in\ref{eq::K_two_pace} and the four-paced gait was produced using the coupling matrix defined in \ref{eq::K_four_pace}. 
			Figure \ref{fig::cpg_transition} shows the change in output state patterns during a transition from a four-paced to a two-paced gait. Figure~\ref{fig::real_cpg_joints} shows joint angle feedback from the actual robot platform during the execution of a CPG driven gait which achieves a ground-speed of $65 \frac{mm}{s}$.
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				\begin{figure}
					\centering
					\fbox{\includegraphics[width=1.00\textwidth]{cpg_phase2_45.png}}
					\caption{CPG output and phase plots for a two-paced gait over two gait cycles.}
					\label{fig::cpg_phase2_45}
				\end{figure}
				\begin{figure}
					\centering
					\fbox{\includegraphics[width=1.00\textwidth]{cpg_phase4_45.png}}
					\caption{CPG output and phase plots for a four-paced gait over two gait cycles.}
					\label{fig::cpg_phase4_45}
				\end{figure}
				\begin{figure}
					\centering
					\fbox{\includegraphics[width=1.00\textwidth]{cpg_transition.png}}
					\caption{CPG output transition during four-pace to two-pace gait switch.}
					\label{fig::cpg_transition}
				\end{figure}	
				\begin{figure}
					\centering
					\fbox{\includegraphics[width=1.00\textwidth]{real_cpg_joints.png}}
					\caption{Real joint angles during a gait at $65 \frac{mm}{s}$.}
					\label{fig::real_cpg_joints}
				\end{figure}	
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



	\section{Foot Placement Control}
		\label{sec::foot_placement_control}

		A foot placement controller has been implemented which utilizes CPG outputs (defined in equation \ref{eq::cpg_ss_def}) in concert with a virtual-force controller. This controller is designed such that each foothold of the robot tracks the foot positions of a virtual robot generated through a model reference. The virtual robot is described by the foot positions, $\tilde{p}_{i,e}$, a virtual reference configuration corresponding to the position, $\tilde{p}_{c}$, and orientation, $\tilde{\theta}_{c}$, of the main body in $O_{0}$. The robot follows the foot placement of the virtual robot to achieve a commanded ground speed $v^{r} > 0$ in a unit-vector direction $\vec{u}^{r} \in \RRe^{3}$; and turning velocity $\omega^{r} \in \RRe$. Each virtual point is updated by:
		\begin{eqnarray}
			\dot{\tilde{\theta}}_{c}	& = & \omega^{r} 				\nonumber\\
			\dot{\tilde{p}}_{c}			& = & v^{r}\vec{u}^{r}			\nonumber\\
			\dot{\tilde{p}}_{i,e} 		& = & v^{r}\vec{u}^{r} + \Skew{\omega^{r}\vec{h}_{c}} \tilde{R}_{c} \wrap{\tilde{p}_{i,e}-\tilde{p}_{c} } 
			\label{eq::virtual_foothold_control}
		\end{eqnarray}
		where $\vec{h}_{c}$ is a unit vector that is orthogonal and pointed outward from the surface beneath the robot; $\Skew{\omega^{r}\vec{h}_{c}}\text{ }\in\text{ }\RReal^{3\times3}$ forms a skew-symmetric matrix from the vector argument $\omega^{r}\vec{h}_{c}$; and $\tilde{R}_{c}$ defines a rotation matrix about the unit normal $\vec{h}_{c}$ by an angle $\tilde{\theta}_{c}$. The dynamics of $\dot{\tilde{p}}_{i,e}$ progress target footholds at a commanded translational (forward) and rotational velocity, $v^{r}$ and $\omega^{r}$, respectively. The robot follows the virtual model at nearly the same velocities with minimal lag so long as the system bandwidth is not exceeded. Using this virtual-foothold method is convenient as it allows for foot-placement planning to be independent of foot-trajectory planning. For example, terrain adaptation can be incorporated by modifying the location of virtual foot positions such that they conform to an upcoming surface. The robot's gait will then track these adaptations without any explicit modification of foot trajectories. In the event of contact with unperceived terrain, virtual-foothold positions will reset with respect to an estimated point of contact for each \Ith contacting foot (see Algorithm~\ref{alg::foot_reset}). In Algorithm~\ref{alg::foot_reset}, $y_{2,i}>0$ indicates that the \Ith foot is in flight, as per the definition of the foot-height controller to be defined in~\ref{eq::foot_height_control}. The foot-position estimate $\hat{p}_{i,e}$ is defined in~\ref{eq::foot_position_esitmate}.

			\begin{algorithm}[!h]
				\begin{algorithmic}
				\ForAll{$i$ \textbf{in} $i = \{1,...,4\}$}
					\If{ $y_{2,i}>0$ \textbf{and} $\mu_{i}=1$}
						\State{$\tilde{p}_{i,e} = \hat{p}_{i,e}$}
					\EndIf
				\EndFor
				\end{algorithmic}
				\caption{Virtual foothold reset routine.}
				\label{alg::foot_reset}
			\end{algorithm}
			\begin{figure}[!h]
				\centering
				\fbox{\includegraphics[width=1.00\textwidth]{virtual_foothold.png}}
				\caption{Virtual foothold representation. Blue arrows represent an attractive ``force" between the feet and their corresponding virtual foothold.}
				\label{fig::virtial_foothold}
			\end{figure}

		The full foothold controller is represented by 
			\begin{equation}
				\dot{p}_{i,e}^{r} = \dot{\tilde{p}}_{i,e}^{v} + \dot{\tilde{p}}_{i,e}^{y}, \SSep i = \{1,...,4\}
			\end{equation} 
		is a composite of a foot-repositioning and step-height controller which are formulated in terms of the dynamics of the signals $\dot{\tilde{p}}_{i,e}^{v}$ and $\dot{\tilde{p}}_{i,e}^{y}$, respectively. $\dot{p}_{i,e}^{r}$ is a reference position command for each \Ith foot. Each foot is treated as a point mass attracted to the corresponding virtual foothold by an over-damped mass-attractor system. $\dot{\tilde{p}}_{i,e}^{v}$ is defined by
			\begin{equation}
				\dot{\tilde{p}}_{i,e}^{v} 		= \frac{1}{m_{i}} \int^{t}_{0}{{P}_{\vec{h}_{i}} \wrap{ F_{s,i}  -b_{c} \dot{p}_{i,e}^{r} + F_{\epsilon,i} } d\tau}
				\label{eq::foot_place_control}
			\end{equation}
		where
			\begin{eqnarray*}
				F_{s,i} 			& = & k_{c} \wrap{ \tilde{p}_{i,e} - {p}_{i,e}^{r} } \Unit{y_{2,i}}		\nonumber\\
				F_{\epsilon,i}		& = & a_{\epsilon}\dot{\epsilon}_{\theta} \Unit{y_{2,i}}						\nonumber
			\end{eqnarray*}
	 	with $k_{c},b_{c},a_{\epsilon},m_{i} \in \RReal$.
		$k_{c}$ and $b_{c}$ represent  attraction and viscous damping constants for the virtual force system. ${P}_{\vec{h}_{i}}(*)$ projects the sum of  forces, $(*)$, onto the surface beneath the \Ith foot orthogonal to $\vec{h}_{i}$. $\Unit{y_{2,i}}$ is a standard unit step function. The force $F_{\epsilon,i}$ is a compensatory force to adjust for the inertial disturbance,  $\dot{\epsilon}_{\theta}$. For instance, if the robot was pushed from the side of its body, this force would induce a side-stepping motion to attempt to prevent the robot from falling in the direction of the push. Because of $\Unit{y_{2,i}}$, $F_{s,i}$ and $F_{\epsilon,i}$ are nonzero only when $y_{2,i}$ is positive.

		The controller component $\dot{\tilde{p}}_{i,e}^{y}$ is defined from the CPG output signal $\dot{y}_{2,i}$. The height of each step is made proportional to the magnitude of desired platform velocity
			\begin{equation}
				\dot{\tilde{p}}_{i,e}^{y} 	= { \wrap{ \alpha_{v} v^{r} + \alpha_{\omega} \abs{\omega^{r}} } \dot{y}_{2,i}} \vec{h}_{i} 
				\label{eq::foot_height_control}
			\end{equation}
		where $\alpha_{v}$ and $\alpha_{\omega}$ are scalar weighting parameters; and $\vec{h}_{i}$ represents a unit normal projecting from the surface beneath each \Ith foot. Scaling step height relative to command parameters $v^{r}$ and $\omega^{r}$ has been seen in experimental studies to be more effective than using a fixed step-height for all gait configurations. Figures \ref{fig::foot_motion2} and \ref{fig::foot_motion4} show stepping patterns generated using the aggregate virtual-force foothold controller and CPG motion outputs during two and four-paced gaits, respectively, which achieve a forward velocity of $v^{r}=40\frac{mm}{s}$. The sequence of foot contacts made during each gait is enumerated in each figure. Red, green, blue, and cyan dots represent contacts made by the front-right, front-left, back-left, and back-right feet, respectively.
%
			\begin{figure}[!h]
				\centering
				\fbox{\includegraphics[width=1.00\textwidth]{step_pattern_2.png}}
				\caption{Stepping pattern generated using virtual-force foothold controller during two-pace gait sequence at $v^{r}=40\frac{mm}{s}$.}
				\label{fig::foot_motion2}
			\end{figure}
			\begin{figure}[!h]
				\centering
				\fbox{\includegraphics[width=1.00\textwidth]{step_pattern_4.png}}
				\caption{Stepping pattern generated using virtual-force foothold controller during four-pace gait sequence at $v^{r}=40\frac{mm}{s}$.}
				\label{fig::foot_motion4}
			\end{figure}
%



	\section{ZMP Based Trunk-Placement Control}

		A  modified Zero-Moment-Point (ZMP) based controller is utilized in positioning BlueFoot's body during gaiting. In this context, the ZMP of the system is a set of state values for which the net-torque exerted upon the system, about the COG, is zero \cite{Kajita2003,Katie2009}. Unlike \cite{Takanishi1989,Kurazume2003}, which address ZMP-based control by considering the robot's body as a point-mass with massless limbs, this method takes into account the torque contribution of each non-supporting leg. Each leg in flight is considered as a series of point masses whose locations are computed using joint position feedback and trunk orientation estimates, in concert with the robot's forward kinematic model.
		
		The ZMP approach is used to first calculate static ZMP configurations ( \IE $\ddot{p}_{COG}\approx0$) at each time instance. The distance between the robot's COG and associated ZMP is incrementally minimized on-line by treating the ZMP as a  mass-attractor and ``pulling" a reference body position, ${p}_{b}^{b',r}$, towards the ZMP point at each update. This differs from approaches similar to \cite{Kurazume2003} because these routines feature off-line, trunk trajectory design which aim to minimize deviations between the robot's COG and ZMP by creating an appropriate limit-cycle motion for the robot's trunk. These approaches typically utilize simplified, linearized models of the actual system about marginally-stable equilibrium points. To realize an adjustment of the robot's COG, towards the ZMP, BlueFoot's trunk position is modified during the execution of a gait. The trunk is controlled (and not individual feet) as it contributes most of the system's total mass and, thus, has the greatest influence over the location of the platform's COG. Restricting adjustments to the trunk's translational states allows pre-planned foot trajectories to remain unmodified by the ZMP-control module during gait execution, thus decoupling foot-placement and body-placement control.

		To incrementally compute the static ZMP of the platform, a measure of net-moment on the body of the platform must be known. The net-moment due to gravitational forces, $\tau_{net}$, is approximated using the locations of each link and joints as point-mass loads. Hence, $\tau_{net}$ is calculated as follows:
			\begin{equation}
				\tau_{net} 	=  \wrap{\bar{p}_{b}^{b'}-\hat{p}_{COG}^{b'} } \times \wrap{\vec{g} m_{b}}	+ \tau_{legs}
				\label{eq::net_moment}
			\end{equation}
		where
			\begin{eqnarray*}
					\tau_{legs}		& = & \Sum{i}{1}{4} (1-\mu_{i}) \wrap{ m_{i,e} p_{i,e}^{b'} + \Sum{i}{1}{4}   \wrap{ m_{i,j}^{J} d_{i,j}^{J} + m_{i,j}^{L} d_{i,j}^{L} } } \times \vec{g} \nonumber \\
					d_{i,j}^{J} 	& = & {{p}_{i,j}^{b'}-\hat{p}_{COG}^{b'}.} \nonumber \\														
					d_{i,j}^{L} 	& = &
					\begin{cases}
					{ 0.5  \wrap{{p}_{i,j+1}^{b'}-{p}_{i,j}^{b'}} + {p}_{i,j}^{b'} - \hat{p}_{COG}^{b'}} 	&\text{if } j < 4 \\
					{ 0.5  \wrap{{p}_{i,e}^{b'}-{p}_{i,j}^{b'}} + {p}_{i,j}^{b'} - \hat{p}_{COG}^{b'}} 		&\text{if } j = 4.
					\end{cases} \nonumber
				\label{eq::Levers}
			\end{eqnarray*}
		The terms $m_{b}$, $m_{i,j}^{J}$, $m_{i,j}^{L}$, $m_{i,e}$ represent the mass of the main body; the mass of each joint; the mass of each link; and the mass of each foot, respectively. $\mu_{i}$ is included in the above formulation such that only stepping (non-contacting) legs contribute to  $\tau_{legs}$. ${p}_{b}^{b'}$, ${p}_{i,j}^{b'}$, and ${p}_{i,e}^{b'}$ represent the position of the trunk; the position of each \Jth joint; and the position of each foot of the \Ith leg in the robot-relative frame $O_{b'}$, as defined in Section~\ref{sec::system_kinematics}. This allows the control routine to be performed without explicit knowledge of the robot's absolute position in $O_{0}$. The estimated center of gravity in $O_{b'}$, $\hat{p}_{COG}^{b'}$, is generated as follows:
			\begin{eqnarray}
				\hat{p}_{COG}^{b'} 	& = & \frac{1}{m_{T}}\wrap{ m_{b}p_{b}^{b'} + \sum_{i=1}^{4} \wrap{m_{i,e}{p}_{i,e}^{b'} + \sum_{j=1}^{4} \wrap{  m_{i,j}^{J}{p}_{i,j}^{b'} +  m_{i,j}^{L}{p}_{i,j}^{b',L} } }} 	\nonumber \\
				{p}_{i,j}^{b',L} 	& = & 
					\begin{cases}
					{ 0.5  \wrap{{p}_{i,j+1}^{b'}-{p}_{i,j}^{b'}} + {p}_{i,j}^{b'} } 	&\text{if } j < 4 \\
					{ 0.5  \wrap{{p}_{i,e}^{b'}-{p}_{i,j}^{b'}} + {p}_{i,j}^{b'} } 		&\text{if } j = 4
					\end{cases}
				\label{eq::cog_estimate}
			\end{eqnarray}
		where
			\begin{equation}
				m_{T} = m_{b} + \sum_{i=1}^{4} \wrap{m_{i,e} + \sum_{j=1}^{4} \wrap{  m_{i,j}^{J} +  m_{i,j}^{L} } }.
			\end{equation}
		Here, the local COG of each linkage, ${p}_{i,j}^{L}$, is assumed to be at the midpoint along the length of each link, half-way between two successive joints.
			\begin{figure}[!h]
				\centering
				\fbox{\includegraphics[width=1.00\textwidth]{body_motion.png}}
				\caption{Body motion generated using ZMP controller during two-pace \emph{(top)} and four-pace \emph{(bottom)} gaiting sequence.}
				\label{fig::body_motion}
			\end{figure}
		Setting $\tau_{net}=0$, \ref{eq::net_moment} is manipulated to a derived solution for the ZMP as follows:
			\begin{equation}
				{p}_{ZMP}^{b'} = R_{z_P} \wrap{\frac{\pi}{2}}  \wrap{ \frac{m_{b}}{\norm{g}}} \tau_{legs} + \hat{p}_{COG}^{b'}.
				\label{eq::ZMPFromMoment}
			\end{equation}
		Using ${p}_{ZMP}^{b'}$, the platform's posture is then updated using a virtual-force controller. Moreover, ${p}_{b}^{b'}$ is to be controlled through  ${p}_{b}^{b',r}$ such that it is smoothly attracted to ${p}_{ZMP}^{b'}$. The controller is given by
			\begin{equation}
				\dot{p}_{b}^{b',r} 	= {P}_{\vec{h}_{i}} \wrap{K_{Z}	( {p}_{ZMP}^{b'} - {p}_{b}^{b'} )  
				+ K_{F}\frac{F_{r}}{m_{b}}  }
				\label{eq::ZMPController}
			\end{equation}	
		where
			\begin{eqnarray*}
				F_{r} 	& = &  \Sum{i}{1}{4}  e^{\wrap{ k_{l} r_{i}^{-} } } + e^{ \wrap{ k_{l} r_{i}^{+} } } \nonumber \\
				r_{i}^{+}	& = & \norm{{p}_{i,e}^{b'}- {p}_{b}^{b'}} - r_{max} \nonumber \\
				r_{i}^{-}	& = & r_{min} - \norm{{p}_{i,e}^{b'}- {p}_{b}^{b'}} \nonumber
			\end{eqnarray*}
		and $K_{Z}, K_{F}, k_{l} > 0$ and $\dot{p}_{b}^{b',r}$ is the reference body velocity. $F_{r}$ is a boundary force added to ensure that the workspace of each manipulator, defined by the radii $r_{min}$ and $r_{max}$, is not exceeded when the body is repositioned. $k_{l}$ is picked to be adequately large such that this force is nearly zero when the body and foot positions comply with the local workspace of each leg, and large when the workspace is nearly compromised, forcing the placement of the body to comply with each leg workspace. Figure~\ref{fig::body_motion} shows a trajectory for the trunk position reference, ${p}_{b}^{b',r}$, and actual body trajectory, ${p}_{b}^{b'}$ generated using the aforementioned ZMP-based body-placement controller during a gait which achieves a forward velocity of $v^{r}=40\frac{mm}{s}$. Here, results are shown for the $x$-axis motion of the body. This is because during forward motion, the most significant alterations to the location of the body are seen along the $x$-axis.



	\section{Trunk Leveling via NARX-Network Learning Approach}
		\label{sec::trunk_leveling_NARX}
		
		Suppressing disturbances which enter a quadruped system during gaiting is a matter which requires special handling, given the dynamical complexity of both the robot and its interactions with the environment. This complexity can be handled, in part, by a learning-based approach. This section will focus on the formulation of a learning controller used to reject disturbances from the orientation states of the trunk of a legged robot. Disturbance rejection from the trunk sub-system of a legged platform has practical significance when carrying a payload (such as cameras, optical systems, armaments, etc.) rigidly fixed to their main body. Disturbances are imparted upon the trunk during gaiting in two main ways: 
		\begin{enumerate}
			\item instantaneous changes in force distribution when feet make and break contact with the ground 
			\item under-actuation that occurs during certain dynamic gaits. During dynamic gaits, such as trot gaits, the state of contact between the feet and the ground is changed often so as to prevent the walking robot from tipping past a recoverable configuration. 
			\end{enumerate}
		Additionally, these gaits feature the utilization of two or fewer legs to support the trunk at any given time, causing the system to enter an under-actuated state where the body is free to rock about the planted feet, as shown in Figure \ref{fig::quadruped_walking}.
		%%
			\begin{figure}[!h]
			\centering
				\fbox{\includegraphics[width=1.00\textwidth]{tipping_robot.png}}
				\caption{Quadruped tipping about planted feet.}
				\label{fig::quadruped_walking}
			\end{figure}
		%%
		To achieve disturbance rejection on the trunk orientation and to attain a fixed orientation, experimentation has been performed using a control methodology which utilizes a Nonlinear Autoregressive Neural Network with Exogenous inputs (NARX-NN) as part of an active compensation mechanism. The network is used to estimate the system dynamics and, further, predict periodic disturbances in an on-line fashion. The compensator is utilized to modify reference joint trajectories by way of a weighted sum between the original joint trajectories generated by the gaiting mechanism and a reference correction signal generated by the compensator.

		\subsection{NARX-Neural Network}


			Using a NARX-NN (introduced in Chapter \ref{ch::introduction}), the dynamical estimate $\hat{\Phi}_{k}$ is generated as a prediction of the sampled system dynamics, $\hat{\psi}_{k+1}$. The relationship between $\hat{\Phi}_{k}$ and the network prediction $\hat{\psi}_{k+1}$will be made clear in the description of the network training signal given in \ref{eq::training_signal}. The general input-output relationship of the NARX-NN predictor, ${\cal N}$, is described as follows:
			%%%
			%%%
				\begin{eqnarray}
					\hat{\psi}_{k+1}	&=& {\cal N}(\hat{\Psi}_{k}^{N},{U}_{k}^{N}) \nonumber\\
					\hat{\Psi}_{k}^{N}	&=& [\hat{\psi}_{k},\hat{\psi}_{k-1},...,\hat{\psi}_{k-N+1}]  \nonumber\\
					{U}_{k}^{N}		&=& [u_{k}   ,u_{k-1}   ,...,u_{k-N+1}   ]
					\label{eq::narx_model}
				\end{eqnarray}
			%%%
			%%%
			where ${U}_{k}^{N}$  and $\hat{\Psi}_{k}^{N}$ are collections of $N$ most recent samples of the network inputs, $u_{k}$, and the network output, $\hat{\psi}_{k}$, respectively. The NARX-NN input, $u_{k}$, represents a tuple $u_{k} = (z_{1,k}, z_{2,k}, f_{ext,k})$ whose components are the arguments of $\Phi$ at time instant $k$. 



		\subsection{NARX-NN Training Regimen}
			
			The  NARX-NN training signal is formulated to estimate $\Phi_{k}$ from the system dynamics. By \ref{eq::sampled_dynamics}, it can be seen that $\Phi_{k}$ can be estimated if ${z}_{2,k+1}$ can be predicted. We consider the following target network prediction output, $\psi_{k+1}$,  defined by:
				\begin{equation}
					\psi_{k+1} = \tau_{k} - \hat{M}_{1,k}({z}_{2,k+1} - {z}_{2,k})\Delta_{s}^{-1} = \Phi_{k} - {e}_{2,k}^{\Delta_{s}} \text{ .}
					\label{eq::training_signal}
				\end{equation}
			%%
			%%
			This training signal formulation assumes that $\hat{M}_{1,k}$ represents $M_{1,k}$ exactly, which is likely not the case given the system's complexity. In the absence of a well-modeled $\hat{M}_{1,k}$, a constant symmetric $\hat{M}_{nom}$ will be picked such that $\hat{M}_{1,k} = \hat{M}_{nom} \forall k$. $\hat{M}_{nom}$ has the following structure:
				\begin{equation}
					\hat{M}_{nom} = \left[
						\begin{array}{cc}
						\hat{M}_{bb}	&	 \hat{M}_{bq}\\
						\hat{M}_{qb}	&	 \hat{M}_{qq}
						\end{array}
					\right]
				\end{equation}
			where 	$\hat{M}_{bb}\RRealMat{6}{6}$, 
					$\hat{M}_{bq}=\hat{M}_{qb}^{T} \RRealMat{6}{16}$, and  
					$\hat{M}_{qq}\RRealMat{16}{16}$. 
			It is particularly important that $\hat{M}_{bq}\neq0$ to reflect some degree of coupling between the joint states $q$ and the trunk states ${p}_{b}$ and $\theta_{b}$. In general, $\hat{M}_{nom}$ should be selected to reflect the \emph{average} system mass matrix over the range of configurations, $z_{1}$, seen during gaiting. This approximation has shown to be adequate from our results, and depends on the assumption that changes in $\hat{M}_{1,k}$ are small  over the subset of state values $z_{1}$ experiences during a periodic gaiting sequence. Future improvements of this controller involve the formulation of a separate estimator for $M(z_{1})$ or a control/learning scheme with no direct dependence on $M(z_{1})$.

			Since $\hat{\psi}_{k+1}$ is non-causal, training is performed one time-step after a prediction is made using the input-output pair $\hat{\psi}_{k}$ and \{${\Psi}_{k-1}^{N}$, ${U}_{k-1}^{N}$\}. Note that $\hat{\psi}_{k}$ can calculated directly using \ref{eq::training_signal} where all component signals are time-delayed by one time-step. Training can then be described by:
				\begin{equation}
					\psi_{k} \xrightarrow{BP(\gamma^{lr})} {\cal N}({\Psi}_{k-1}^{N},{U}_{k-1}^{N})
					\label{eq::training}
				\end{equation}
			where $\gamma^{lr} _{min} < \gamma^{lr} < \gamma^{lr} _{max}$ is a learning rate adapted using a \emph{bold-driver} update routine. Bold-driver learning-rate adaptation is a  heuristic method for speeding up the rate of convergence of back-propagation training regimes \cite{Battiti1992,Magoulas1999}. This $\gamma^{lr}$ update law is parameterized by $\beta \in (0,1)$ and $\zeta \in (0,1)$ which are selected to specify the amount by which $\gamma^{lr}$ increases or decreases per update, and $\gamma^{lr} _{min}$ and $\gamma^{lr} _{max}$ which are used to saturate $\gamma^{lr}$.  The bold-driver scheme utilizes the current and previous mean-squared network output error values ($MSE_{k}$ and $MSE_{k-1}$, respectively) to adjust $\gamma^{lr}$ as follows:
				\begin{equation}
				    \gamma^{lr} \leftarrow 
					\begin{cases}
				    \gamma^{lr} (1- \beta) 		& \text{if } MSE_{k} > MSE_{k-1}\\
				    \gamma^{lr} (1+\zeta \beta),& \text{otherwise}.
					\end{cases}
				\end{equation}
			Since network training is being performed on-line as an incremental routine, the effective mean-squared NARX-NN  output error is low-pass filtered using a factor $\lambda \in (0,1)$. This update technique has been selected to ensure that outliers presented during training do not affect network learning updates as significantly as ``nominal" training pairs. Network output error, $e_{{\cal N},k}$, and its associated MSE values are calculated after each prediction by:
				\begin{eqnarray}
					e_{{\cal N},k} 	&=& \hat{\psi}_{k} - \psi_{k} \nonumber\\
					MSE_{k} 		&\leftarrow& \lambda \|e_{{\cal N},k}\|_{2}^{2} + MSE_{k-1}(1-\lambda).
				\end{eqnarray}


		\subsection{Compensator Output}

			The control scheme is first presented with respect to the servo input torques, $\tau_{q,k}$, and formulated to achieve a level trunk characterized by $\theta_{b}=0$, $\dot{\theta}_{b}= 0$. To formulate this controller, the dynamical sub-system which corresponds to the un-actuated trunk orientation states is isolated by:
				\begin{equation}
					\ddot{\theta}_{b} 	= \Gamma_{1} M^{-1}(z_{1})( \Gamma_{2}\tau_{q}	 + \Phi)
					\label{eq::sub_dynamics}
				\end{equation}
			where 
				\begin{eqnarray*}
					\Gamma_{1} &=& [0_{3\times3},I_{3\times3},0_{3\times16}] \nonumber\\
					\Gamma_{2} &=& [0_{16\times6},I_{16\times16}]^{T}	
				\end{eqnarray*}
			and $\Gamma_{2}\tau_{q}$ is equivalent to the original system input, $\tau$. In order to enforce a level platform with zero angular velocity, we seek a $\tau_{q}$ which emulates the proportional-derivative (P.D.) control law:
				\begin{equation}
				 	\ddot{\theta}_{b} = - K_{b}{\theta}_{b} - K_{d}\dot{\theta}_{b}
				\end{equation}
			where $K_{b}$ and $K_{d}$ are constant gain matrices. Using this P.D. law and \ref{eq::sub_dynamics}, we propose a least-squares solution for $\tau_{q}$ by:
				\begin{equation}
					\tau_{q} \approx -\left[\Gamma_{1} M^{-1}(z_{1}) \Gamma_{2}\right]^{\dagger}
					\sbrack{\Gamma_{1} M^{-1}(z_{1})\Phi + K_{b}{\theta}_{b} + K_{d}\dot{\theta}_{b}}
					\label{eq::psuedo_torque}
				\end{equation}
			where $\left[*\right]^{\dagger}$ denotes the Moore-Penrose pseudo-inverse of $[*]$.
			%%
			Replacing all dynamical terms with their associated discrete-time equivalents, and $\Phi$ by the NARX-NN output $\hat{\Phi}_{k}=\hat{\psi}_{k+1}$, we apply \ref{eq::psuedo_torque} to arrive at the following required joint torque estimate:
				\begin{equation}
					\hat{\tau}_{q,k} =  -\left[\Gamma_{1} \hat{M}^{-1}_{1,k} \Gamma_{2}\right]^{\dagger} 
					\sbrack{\Gamma_{1}\hat{M}^{-1}_{1,k}\hat{\psi}_{k+1} + K_{b}{\theta}_{b,k} + K_{d}\dot{\theta}_{b,k}}
					\label{eq::psuedo_torque_k}
				\end{equation}
			where ${\theta}_{b,k}$ and $\dot{\theta}_{b,k}$ are samples of angular trunk position and rate, respectively.


			Using the joint controller dynamics presented in \ref{eq::servo_control_dynamics} and the estimate $\hat{\tau}_{q,k}$, we can formulate a reference-trajectory correction  which is used to alter the joint reference positions, ${q}_{k}^{r}$. Moreover, the corrected reference position, ${q}_{1,k}^{r,*}$ is generated such that the estimated output torque $\hat{\tau}_{q,k}$ is attained by each joint controller. This joint-reference compensator output is defined using 
			\ref{eq::psuedo_torque_k} as follows:
				\begin{equation}
				 	{q}_{1,k}^{r,*} 	= k_{s}^{-1}  \left(  \hat{\tau}_{q,k}  \right) +  {q}_{1,k}.
					\label{eq::correction_equation}
				\end{equation}
			The correction signal,  ${q}_{k}^{r,*}$, is combined with the original gaiting trajectory signal, ${q}_{k}^{r}$, as a weighted sum to form a compensated joint control reference signal, $\tilde{q}_{k}^{r}$, defined by:
				\begin{equation}
				 	\tilde{q}_{k}^{r} 	\leftarrow (1-\alpha) {q}_{k}^{r} + \alpha ( {q}_{k}^{r,*} )
					\label{eq::correction_application}
				\end{equation}
			where  $\alpha \in (0,1)$ is a uniform mixing parameter. The parameter $\alpha$ must be tuned with respect to the stability margins of the gait being compensated. The resultant $\tilde{q}_{k}^{r}$ is then applied  to each joint controller in place of the original reference signal,  ${q}_{k}^{r}$,  generated by the gait controller. Selection of the parameter $\alpha$ is crucial for achieving good performance. 

				\begin{figure}[!h]
					\centering
					\fbox{\includegraphics[width=1.00\textwidth]{controller_diagram.png}}
					\caption{Full system diagram with NARX-NN compensator mechanism.}
					\label{fig::sys_diagram}
				\end{figure}


		\subsection{NARX-NN Implementation}

			The NARX-NN was implemented as a collection of C code functions. These functions make use of the Fast Artificial Neural Network (FANN) library, which provides structures and interfaces for implementing fully-configurable, feed-forward neural networks natively implemented in C \cite{Nissen03}. This library was selected for the implementation of the feed-forward portion of the NARX network for its speed and flexibility. 


		\subsection{NARX-NN Compensator Results}

			The NARX-NN compensator has been tested, exclusively, in simulation and has been applied to the quadruped as it executes a stable CPG-driven trot gait depicted in Figure~\ref{fig::quadruped_walking}. In these trials, gaiting frequency is adjusted accordingly to achieve particular forward speeds. NARX-NN parameters are fixed for all trials with learning-rate  parameters set to $\beta=0.0001$, $\zeta=0.0005$, and $\lambda = 0.01$. The NARX-Network is configured with two hidden layers containing 50 neurons each. Each input and hidden-layer neuron is modeled using a symmetric sigmoid activation function. Output layer neurons are modeled using linear activation functions to  avoid output-scaling saturation issues. Figure~\ref{fig::narx100_a35_nne} illustrates the convergence of the NARX-NN prediction error when the platform executes a gait at  100~$\frac{mm}{s}$ with $\alpha = 0.35$.

			Contact forces, ${f}_{i,ext}$, are handled in the simulated implementation as they would be on the real BlueFoot platform. This method accounts for the absence of true force-torque sensors on each of BlueFoot's feet and, instead, makes use of the system's binary foot-contact sensors, in conjunction with the IMU. Although contact forces on each foot are accessible in simulation, the force at each foot is estimated using a combination of trunk 3-axis accelerometers and foot contact data. Assuming a rigid system and a uniform distribution of forces to each planted foot, a rough estimate of the force applied to each \Ith planted foot, $\hat{f}_{i}$, can be generated by:
				\begin{equation}
					\hat{f}_{i} = {m_{T}\mu_{i}} \left(\ddot{p}_{b} - \vec{g}\right)/{\sum_{j=1}^{4}{\mu_{j}}}
				\end{equation}
			where $m_{T}$ represents the total system mass; $\mu_{i}\in \{0,1\}$ is the contact state of the \Ith
			foot (a value $\mu_{i}=1$ represents contact); $\vec{g}$ is the gravity vector; and $\ddot{p}_{b}$ is the trunk acceleration in the world frame. Ideally, the measurement of ${f}_{i}$ would be obtained via a 3-axis force-torque sensor placed at each foot.

			All simulated trials are performed over a period of 60 seconds each. During the first 10 seconds of each simulation, the robot moves from sitting position to a standing position and initiates walking. During each simulation period, the NARX-NN compensator is activated (not training)  and deactivated (training)  every 10 seconds. Figures~\ref{fig::narx60_a125_nne}, \ref{fig::narx60_a250_nne} and \ref{fig::narx60_a350_nne} depict an initial set of simulation results showing the effect of varying  the mixing parameter $\alpha\in\{0.125, 0.25, 0.35\}$. For all such trials, the robot performs a trot-gait which achieves a forward speed of 60 $\frac{mm}{s}$. It is expected that as $\alpha$ increases, the compensator will have greater authority over trunk stabilization. From these results, we observe that for all $\alpha$, disturbance magnitude is decreased to some extent. However, for smaller $\alpha$, the compensator is less effectual due to the fact that it has less authority over joint reference signals.  From the results in Figure~\ref{fig::narx60_a250_nne}, it is shown that the compensator improves pitch stability by more than roughly 50\% and roll stability by more than 60\%. Figure~\ref{fig::narx80_a35} shows the compensator's performance at higher gaiting speeds of 80 $\frac{mm}{s}$ and 100 $\frac{mm}{s}$. Here the controller improves both pitch and roll by nearly 50\% and 40\% of the  uncompensated signal magnitude, respectively.

			\newpage

			\begin{figure}
				\centering
				\fbox{\includegraphics[width=0.825\textwidth]{aux_V_100mms_nN_50_nL_2_nns.png}}
				\caption{NARX Network MSE convergence for trial shown in Figure \ref{fig::narx100_a35}.} 
				\label{fig::narx100_a35_nne}
			\end{figure}
			\begin{figure}
				\centering
				\fbox{ \includegraphics[width=0.825\textwidth]{alpha0125_V_60mms_nN_50_nL_2_pos.png} }
				\caption{Trunk orientation during 60 $\frac{mm}{s}$ gait with $\alpha = 0.125$.}
				\label{fig::narx60_a125_nne}
			\end{figure}

			\begin{figure}
				\centering
				\fbox{ \includegraphics[width=0.825\textwidth]{alpha0250_V_60mms_nN_50_nL_2_pos.png} }
				\caption{Trunk orientation during 60 $\frac{mm}{s}$ gait with $\alpha = 0.250$.}
				\label{fig::narx60_a250_nne}
			\end{figure}
			\begin{figure}
				\centering
				\fbox{ \includegraphics[width=0.825\textwidth]{alpha0350_V_60mms_nN_50_nL_2_pos.png} }
				\caption{Trunk orientation during 60 $\frac{mm}{s}$ gait with $\alpha = 0.350$.}
				\label{fig::narx60_a350_nne}
			\end{figure}

			\begin{figure}
				\centering
				\fbox{\includegraphics[width=0.825\textwidth]{aux_V_80mms_nN_50_nL_2_pos.png}}
				\caption{Trunk orientation during 80 $\frac{mm}{s}$ gait with mixing  parameter set to $\alpha = 0.35$.}
				\label{fig::narx80_a35}
			\end{figure}
			\begin{figure}
				\centering
				\fbox{\includegraphics[width=0.825\textwidth]{aux_V_100mms_nN_50_nL_2_pos.png}}
				\caption{Trunk orientation during 100 $\frac{mm}{s}$ gait with $\alpha = 0.35$.} 
				\label{fig::narx100_a35}
			\end{figure}